订单薄无论是在CEX还是DEX中，都是一个核心的数据结构。它记录了市场中所有未成交的买单和卖单，并按照价格优先、时间优先等规则进行排列，从而为撮合引擎提供实时的交易参考。

在 CEX 中，订单簿通常由交易所的中心化服务器维护，数据更新频率极高，撮合过程也完全由平台内部完成。而在 DEX 中，订单簿的实现则更为多样化：既有链上全透明存储与撮合的模式，也有链下维护订单簿、链上结算的混合方案。  
无论哪种形态，**订单簿的设计都直接影响到交易系统的性能、延迟、透明性以及用户体验**。对于开发者而言，理解订单簿的结构、运作机制以及在高并发环境下的优化方法，不仅有助于构建更高效的交易系统，也能更好地权衡去中心化与性能之间的取舍。
  
本文将以 DEX 为主要视角，深入解析订单簿中所涉及到数据结构和其之间的组织形式。

与订单薄相关的代码都在`state/orderbook`中，订单薄的定义在`state/orderbook/book.rs`中，代码如下：

``` Rust
pub struct Orderbook<'a> {
    pub bids: RefMut<'a, BookSide>,
    pub asks: RefMut<'a, BookSide>,
}
```

从订单薄的声明中可以得知一个订单薄包含两个方向的订单集合，分别为买单bids和卖单asks，其类型是`BookSide`，这里可以称之为订单树，声明代码在`state/orderbook/bookside.rs`中，代码如下：

``` Rust
#[account(zero_copy)]
pub struct BookSide {
    pub roots: [OrderTreeRoot; 2],
    pub reserved_roots: [OrderTreeRoot; 4],
    pub reserved: [u8; 256],
    pub nodes: OrderTreeNodes,
}
```

`BookSide`是一个订单树，其中`roots`用于存储树的原数据信息，`nodes`存储实际的节点信息，剩下的`reserved_roots`和`reserved`都是预留字段。

接下来看下`roots`中树的原数据信息都包括什么，`roots`是`OrderTreeRoot`类型，代码在`state/orderbook/ordertree.rs`中，代码如下：

``` Rust
pub type NodeHandle = u32;

#[zero_copy]
pub struct OrderTreeRoot {
    pub maybe_node: NodeHandle,
    pub leaf_count: u32,
}
```

由`OrderTreeRoot`的代码可知，原数据信息包括根节点的索引和树中节点数。树中的节点存储在`nodes`中，其类型是`OrderTreeNodes`，代码也在`state/orderbook/ordertree.rs`，代码如下：

``` Rust
#[zero_copy]
pub struct OrderTreeNodes {
    pub order_tree_type: u8, // OrderTreeType, but that's not POD
    pub padding: [u8; 3],
    pub bump_index: u32,
    pub free_list_len: u32,
    pub free_list_head: NodeHandle,
    pub reserved: [u8; 512],
    pub nodes: [AnyNode; MAX_ORDERTREE_NODES],
}
```

由`OrderTreeNodes`代码可知，订单树中的节点是以数组`nodes`的形式存储的，可以存储叶子节点内部节点，所以这个`nodes`的中存储数组的类型是`AnyNode`类型。使用`bump_index`记录下一个存储节点的索引，而`order_tree_type`用来标识是买单还是卖单树，另一个比较重要的属性是`free_list_len`和`free_list_head`，分别记录了空闲链表长度和空闲链的头索引。

另外`roots`的声明是一个长度为2的数组，也就是说**每个`BookSide`中有两棵订单树**，分别为**固定价格树**和**预言机锚定价格树**，而且这两棵树共享节点池。节点池中存放的节点包括`InnerNode`和`LeafNode`，相关代码在`state/orderbook/nodes.rs`中，如下：

``` Rust
#[zero_copy]
pub struct AnyNode {
    pub tag: u8,
    pub data: [u8; 79],
    // essential to make AnyNode alignment the same as other node types
    pub force_align: u64,
}

#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable, AnchorSerialize, AnchorDeserialize)]
#[repr(C)]
pub struct InnerNode {
    pub tag: u8, // NodeTag
    pub padding: [u8; 3],
    /// number of highest `key` bits that all children share
    /// e.g. if it's 2, the two highest bits of `key` will be the same on all children
    pub prefix_len: u32,
    /// only the top `prefix_len` bits of `key` are relevant
    pub key: u128,
    /// indexes into `BookSide::nodes`
    pub children: [NodeHandle; 2],
    /// The earliest expiry timestamp for the left and right subtrees.
    ///
    /// Needed to be able to find and remove expired orders without having to
    /// iterate through the whole bookside.
    pub child_earliest_expiry: [u64; 2],
    pub reserved: [u8; 40],
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, bytemuck::Pod, bytemuck::Zeroable, AnchorSerialize, AnchorDeserialize)]
#[repr(C)]
pub struct LeafNode {
    /// NodeTag
    pub tag: u8,
    /// Index into the owning OpenOrdersAccount's OpenOrders
    pub owner_slot: u8,
    /// Time in seconds after `timestamp` at which the order expires.
    /// A value of 0 means no expiry.
    pub time_in_force: u16,
    pub padding: [u8; 4],
    /// The binary tree key, see new_node_key()
    pub key: u128,
    /// Address of the owning OpenOrdersAccount
    pub owner: Pubkey,
    /// Number of base lots to buy or sell, always >=1
    pub quantity: i64,
    /// The time the order was placed
    pub timestamp: u64,
    /// If the effective price of an oracle pegged order exceeds this limit,
    /// it will be considered invalid and may be removed.
    ///
    /// Only applicable in the oracle_pegged OrderTree
    pub peg_limit: i64,
    /// User defined id for this order, used in FillEvents
    pub client_order_id: u64,
}
```

`InnerNode`是内部节点，不存储订单本身，主要用来维护订单树的结构，通过`children`记录子节点的索引关系，从`key`中取`prefix_len`作为组织树的依据，`child_earliest_expiry`存储的是该节点的左右子树中最早过期的时间戳。

`LeafNode`是叶子节点，用于存储具体的订单信息，其中`quantity`存储订单的`base lots`数，`timestamp`记录的是订单的生成时间，`owner`是订单所属用户的 `OpenOrdersAccount` 地址，而不是直接的钱包地址，`owner_slot`存储的是该订单在所属 `OpenOrdersAccount` 的订单数组中的槽位索引。

`LeafNode`中的`key`与`InnerNode`中的一样，在内存中的位置也一样，这也是这两个`struct`在`key`之前都有`padding`来占位的原因，`key`是订单树的排序键，由价格、订单方向等生成，用于快速比较和定位节点。

了解这些与订单薄相关的核心数据结构之后，就初步掌握了订单薄的整体架构以及运行方式。

订单薄的运行方式是一个`market`创建一个订单薄`OrderBook`，订单薄`OrderBook`根据订单方向创建两个`BookSide`，分别为买单树和卖单树，每个`BookSide`中又有两棵树，分别为Fixed和OraclePegged，这两棵树通过`OrderTreeNodes`共享节点池，节点池中存储内部节点`InnerNode`和`LeafNode`，`LeafNode`节点存储订单的信息，比如交易的base lots数、下单时间等信息，而`InnerNode`则用于维护订单树的结构，通过`key`来决定是否分叉以及查询路径，通过`children`连接各节点的关系。

各数据结构之间的关系如图
![[orderbook-arch.png]]

这套紧凑且高效的内存布局，使OpenBook-V2能够在链上实现价格优先、时间优先的订单管理，同时支持复杂的订单类型（如预言机锚定价格单）。此订单薄的具体更新细节将在后续的文章中进行介绍。

更多内容可查看在github上的项目--[深入Solana OpenBook-V2源码分析与DeFi 合约实战](https://github.com/hunshenshi/solana-openbookv2-and-defi-in-action)