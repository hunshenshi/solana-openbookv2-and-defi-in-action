前几篇文章介绍了订单薄中相关的数据结构和其关键数据结构Crit-bit树，本篇就跟从代码详细认识下OpenBook-V2中的订单薄Crit-bit树是如何构建的，与原始的Crit-bit树又有哪些区别。

Crit-bit树的构建是由新建订单来触发的，新建的订单会作为叶子节点根据订单方向插入订单树`BookSide`中，在`BookSide`中再根据订单的类型选择**固定价格树**或**预言机锚定价格树**，代码如下：

``` Rust
   pub fn insert_leaf(
        &mut self,
        component: BookSideOrderTree,
        new_leaf: &LeafNode,
    ) -> Result<(NodeHandle, Option<LeafNode>)> {
        let root = &mut self.roots[component as usize]; 
        self.nodes.insert_leaf(root, new_leaf) 
    }
```

这是`BookSide`中的方法，代码位于`src/state/orderbook/bookside.rs`中，其中参数`component`是`BookSideOrderTree`类型，是一个枚举，而`new_leaf`是`LeafNode`类型，因为Crit-bit树的特性，订单肯定是作为叶子节点而插入的，所以这里直接指明为`LeafNode`类型。`BookSideOrderTree`的代码如下：

``` Rust
pub enum BookSideOrderTree {
    Fixed = 0,
    OraclePegged = 1,
}
```

`insert_leaf`的具体逻辑是以`component`作为索引，从`BookSide`中获取对应的根，然后调用`OrderTreeNodes`的`insert_leaf`方法，其签名如下：

``` Rust
    pub fn insert_leaf(
        &mut self,
        root: &mut OrderTreeRoot,
        new_leaf: &LeafNode,
    ) -> Result<(NodeHandle, Option<LeafNode>)> {
	...
    }
```

其代码逻辑可以分为四部分，分别为**判断是否为新树**、**下探找寻插入位置**、**更新树**和**更新过期信息**。

### 判断是否为新树
当树为空树时，新节点直接作为根节点插入，相关代码如下：

``` Rust
        // deal with inserts into an empty tree
        let mut parent_handle: NodeHandle = match root.node() {
            Some(h) => h,
            None => {
                // create a new root if none exists
                let handle = self.insert(new_leaf.as_ref())?;
                root.maybe_node = handle;
                root.leaf_count = 1;
                return Ok((handle, None));
            }
        };
```

调用`root.node()`获取根节点，如果不存在则调用`self.insert`插入节点，并更新根节点，如果存在，则将根节点的索引赋值给`parent_handle`，由后续代码根据`parent_handle`进行下探。

### 下探找寻插入位置
如果树非空，则根据上一步中得到的根节点索引`parent_handle`，从`nodes`中获取根节点，然后根据`new_leaf`不断下探去查找合适的插入位置，相关代码如下：

``` Rust   
        // walk down the tree until we find the insert location
        loop {
            // require if the new node will be a child of the root
            let parent_contents = *self.node(parent_handle).unwrap();
            let parent_key = parent_contents.key().unwrap();
            if parent_key == new_leaf.key {
                // This should never happen because key should never match
                ...
                // InnerNodes have a random child's key, so matching can happen and is fine
            }
            let shared_prefix_len: u32 = (parent_key ^ new_leaf.key).leading_zeros();
            match parent_contents.case() {
                None => unreachable!(),
                Some(NodeRef::Inner(inner)) => {
                    let keep_old_parent = shared_prefix_len >= inner.prefix_len;
                    if keep_old_parent {
                        let (child, crit_bit) = inner.walk_down(new_leaf.key);
                        stack.push((parent_handle, crit_bit));
                        parent_handle = child;
                        continue;
                    };
                }
                _ => (),
            };
            ...
        }
```

这段代码是一个循环，**首先**从节点池`nodes`中根据索引`parent_handle`获取节点信息`parent_contents`，无论该节点是`InnerNode`还是`LeafNode`，其中都存储了用于定位分歧点的`key`信息，调用`(parent_key ^ new_leaf.key).leading_zeros()`获取公共前缀的长度。**然后**根据`parent_contents`的类型决定是否需要调用`InnerNode.walk_down`进行下探。当`parent_contents`是`InnerNode`时，判断`shared_prefix_len`是否大于等于`inner.prefix_len`，如果是则调用`inner.walk_down`获取需要下探的子树以及子树方向，跳出此次循环，开始下一次循环。当`parent_contents`是`LeafNode`时则继续执行后续代码。

### 更新树
下探到叶子节点之后，根据`shared_prefix_len`得出mask，根据mask确定左右子树，然后更新树，具体代码如下：

``` Rust
            let crit_bit_mask: u128 = 1u128 << (127 - shared_prefix_len);
            let new_leaf_crit_bit = (crit_bit_mask & new_leaf.key) != 0;
            let old_parent_crit_bit = !new_leaf_crit_bit;

            let new_leaf_handle = self.insert(new_leaf.as_ref())?;
            let moved_parent_handle = match self.insert(&parent_contents) {
                Ok(h) => h,
                Err(e) => {
                    self.remove(new_leaf_handle).unwrap();
                    return Err(e);
                }
            };

            let new_parent: &mut InnerNode = cast_mut(self.node_mut(parent_handle).unwrap());
            *new_parent = InnerNode::new(shared_prefix_len, new_leaf.key);

            new_parent.children[new_leaf_crit_bit as usize] = new_leaf_handle;
            new_parent.children[old_parent_crit_bit as usize] = moved_parent_handle;
```

mask是下探的叶子节点和新节点高位中第一个不同的bit位，通过`1u128 << (127 - shared_prefix_len)`计算得出`crit_bit_mask`，然后根据`crit_bit_mask`与`new_leaf.key`计算所处的位置，`0`是左子树，`1`是右子树。
得出左右子树的位置之后，将下探得到的叶子节点`parent_contents`和要插入的新节点`new_leaf`调用`self.insert`插入到节点池`nodes`中，然后清空`parent_contents`原位置的节点内容，也就是索引是`parent_handle`的节点，并将其作为新的父节点，连接到左右子树上。**这样复制原节点的好处是不用更改上游节点，只插入新的节点，然后调整子树就可以了**。

### 更新过期信息
树结构调整好之后，还需要更新下最早过期时间，这里需要使用`stack`来记录从根到叶子节点的路径，从而可以向上更新祖先的最早过期时间。相关代码如下：

``` Rust
        // path of InnerNode handles that lead to the new leaf
        let mut stack: Vec<(NodeHandle, bool)> = vec![];
		...
		loop {
			...
            let new_leaf_expiry = new_leaf.expiry();
            let old_parent_expiry = parent_contents.earliest_expiry();
            new_parent.child_earliest_expiry[new_leaf_crit_bit as usize] = new_leaf_expiry;
            new_parent.child_earliest_expiry[old_parent_crit_bit as usize] = old_parent_expiry;

            // walk up the stack and fix up the new min if needed
            if new_leaf_expiry < old_parent_expiry {
                self.update_parent_earliest_expiry(&stack, old_parent_expiry, new_leaf_expiry);
            }

            root.leaf_count += 1;
            return Ok((new_leaf_handle, None));
        }
```

因为树的传递性，所以这里会用到`stack`来记录叶子下探的路径，方便向上更新记录的左右子树的最早过期时间，`stack`的更新发生在下探的过程中。
其更新流程是先更新`new_parent`节点的过期时间，然后新插入叶子节点的过期时间决定是否向上更新，如果需要更新则调用`self.update_parent_earliest_expiry`进行向上更新。

## 支撑插入流程的底层方法
在整个插入节点的过程中有几个方法需要单独分析下，分别为`OrderTreeNodes.insert`、`InnerNode.walk_down`和`OrderTreeNodes.update_parent_earliest_expiry`。

### OrderTreeNodes.insert
`insert`是`OrderTreeNodes`的一个内部方法，用于插入叶子节点内容，在`insert_leaf`中被调用。代码如下：

``` Rust
    fn insert(&mut self, val: &AnyNode) -> Result<NodeHandle> {
        match NodeTag::try_from(val.tag) {
            Ok(NodeTag::InnerNode) | Ok(NodeTag::LeafNode) => (),
            _ => unreachable!(),
        };

        if self.free_list_len == 0 {
            require!(
                (self.bump_index as usize) < self.nodes.len() && self.bump_index < u32::MAX,
                OpenBookError::SomeError
            );

            self.nodes[self.bump_index as usize] = *val;
            let key = self.bump_index;
            self.bump_index += 1;
            return Ok(key);
        }

        let key = self.free_list_head;
        let node = &mut self.nodes[key as usize];

        match NodeTag::try_from(node.tag) {
            Ok(NodeTag::FreeNode) => assert!(self.free_list_len > 1),
            Ok(NodeTag::LastFreeNode) => assert_eq!(self.free_list_len, 1),
            _ => unreachable!(),
        };

        self.free_list_head = cast_ref::<AnyNode, FreeNode>(node).next;
        self.free_list_len -= 1;
        *node = *val;
        Ok(key)
    }
```

由代码可知其节点写入逻辑是先判断是否存在`FreeNode`，如果不存在就将数据写入索引为`bump_index`的位置处，如果存在则写入索引为`free_list_head`的位置处，然后再更新**free list**的结构。

> 这里提到的free list与`LeafNode`共享节点池`nodes`，free list是在节点被删除时维护的，具体内容在下篇文章中介绍。

### InnerNode.walk_down
`walk_down`是`InnerNode`中的一个公共方法，用于获取节点`search_key`在此节点处的下探方向，代码如下：

``` Rust
    pub(crate) fn walk_down(&self, search_key: u128) -> (NodeHandle, bool) {
        let crit_bit_mask = 1u128 << (127 - self.prefix_len);
        let crit_bit = (search_key & crit_bit_mask) != 0;
        (self.children[crit_bit as usize], crit_bit)
    }
```

节点下探时选择左子树还是右子树是根据`mask`来判断的，代码首先是根据该节点的记录的公共前缀长度`prefix_len`计算出`crit_bit_mask`，然后根据`search_key & crit_bit_mask`的值获取子树的方向。

### OrderTreeNodes.update_parent_earliest_expiry
`update_parent_earliest_expiry`是`OrderTreeNodes`的一个公共方法，但目前其主要是在内部调用，代码如下：

``` Rust
    pub fn update_parent_earliest_expiry(
        &mut self,
        stack: &[(NodeHandle, bool)],
        mut outdated_expiry: u64,
        mut new_expiry: u64,
    ) {
        // Walk from the top of the stack to the root of the tree.
        // Since the stack grows by appending, we need to iterate the slice in reverse order.
        for (parent_h, crit_bit) in stack.iter().rev() {
            let parent = self.node_mut(*parent_h).unwrap().as_inner_mut().unwrap();
            if parent.child_earliest_expiry[*crit_bit as usize] != outdated_expiry {
                break;
            }
            outdated_expiry = parent.earliest_expiry();
            parent.child_earliest_expiry[*crit_bit as usize] = new_expiry;
            new_expiry = parent.earliest_expiry();
        }
    }
```

代码中对`stack`进行反向遍历，根据`parent.child_earliest_expiry[*crit_bit as usize] != outdated_expiry`判断是否结束循环，其中`outdated_expiry`是子树的最早过期时间，而子树的最早过期时间记录在其父节点的`child_earliest_expiry`中，则当其父节点子树的记录的值不等于`outdated_expiry`时退出循环。

更多内容可查看在github上的项目--[深入Solana OpenBook-V2源码分析与DeFi 合约实战](https://github.com/hunshenshi/solana-openbookv2-and-defi-in-action)